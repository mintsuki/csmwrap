#include <efi.h>
#include <video.h>
#include <csmwrap.h>
#include <io.h>

// Generated by: xxd -i vgabios.bin >> vgabios.h
#include <bins/vgabios.h>

void *vbios_loc = NULL;
uintptr_t vbios_size;

static EFI_STATUS FindGopPciDevice(struct csmwrap_priv *priv)
{
    EFI_STATUS                   Status = EFI_SUCCESS;
    EFI_HANDLE                   *HandleBuffer;
    EFI_HANDLE                   Handle;
    UINTN                        HandleCount;
    UINTN                        HandleIndex;
    EFI_GUID gopGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
    EFI_GUID DevicePathGuid = EFI_DEVICE_PATH_PROTOCOL_GUID;
    EFI_GUID PciIoGuid = EFI_PCI_IO_PROTOCOL_GUID;
    EFI_DEVICE_PATH_PROTOCOL *DevicePath;
    EFI_PCI_IO_PROTOCOL *PciIo;
    EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop;

    // Get all handles that support GOP
    Status = gBS->LocateHandleBuffer(
                    ByProtocol,
                    &gopGuid,
                    NULL,
                    &HandleCount,
                    &HandleBuffer
                    );
    if (EFI_ERROR(Status)) {
        printf("Failed to locate GOP handles: %d\n", Status);
        return Status;
    }

    // Iterate through each GOP handle
    for (HandleIndex = 0; HandleIndex < HandleCount; HandleIndex++) {
        // Get the GOP protocol
        Status = gBS->HandleProtocol(
                        HandleBuffer[HandleIndex],
                        &gopGuid,
                        (VOID**)&Gop
                        );
        if (EFI_ERROR(Status)) {
            continue;
        }

        priv->gop = Gop;
        priv->gop_handle = HandleBuffer[HandleIndex];
        break;
    }

    if (priv->gop == NULL) {
        printf("No GOP handle found\n");
        // Free the handle buffer
        gBS->FreePool(HandleBuffer);
        goto Out;
    }

    Status = gBS->HandleProtocol(
                    HandleBuffer[HandleIndex],
                    &DevicePathGuid,
                    (VOID**)&DevicePath
                    );
    // We are done with previous handle buffer atm
    gBS->FreePool(HandleBuffer);
    if (EFI_ERROR(Status)) {
        printf("Failed to get Device Path protocol: %d\n", Status);
        goto Out;
    }

    Status = gBS->LocateDevicePath(
        &PciIoGuid,
        &DevicePath,
        &Handle
        );

    if (EFI_ERROR(Status)) {
        printf("Failed to locate PCI I/O protocol: %d\n", Status);
        goto Out;
    }

    Status = gBS->HandleProtocol(
                    Handle,
                    &PciIoGuid,
                    (VOID**)&PciIo
                    );

    if (!EFI_ERROR(Status)) {
        UINT16 VendorId, DeviceId;
        UINTN Seg, Bus, Device, Function;

        priv->vga_pci_io = PciIo;

        Status = PciIo->GetLocation(
                                    PciIo,
                                    &Seg,
                                    &Bus,
                                    &Device,
                                    &Function
                                    );

        priv->vga_pci_bus = (UINT8)Bus;
        priv->vga_pci_devfn = (UINT8)(Device << 3 | Function);

        Status = PciIo->Pci.Read(
                                PciIo,
                                EfiPciIoWidthUint16,
                                0, // Vendor ID offset
                                1,
                                &VendorId
                                );

        Status = PciIo->Pci.Read(
                                PciIo,
                                EfiPciIoWidthUint16,
                                2, // Device ID offset
                                1,
                                &DeviceId
                                );


        printf("GOP PCI: %04x:%02x:%02x.%02x %04x:%04x\n",
                    Seg, (UINT8)Bus, (UINT8)Device, (UINT8)Function,
                    VendorId, DeviceId);
    } else {
        printf("Failed to get PCI I/O protocol: %d\n", Status);
    }
Out:
  return Status;
}

static EFI_STATUS
GetPciLegacyRom (
  IN     UINT16 Csm16Revision,
  IN     UINT16 VendorId,
  IN     UINT16 DeviceId,
  IN OUT VOID   **Rom,
  IN OUT UINTN  *ImageSize,
  OUT    UINTN  *MaxRuntimeImageLength,   OPTIONAL
  OUT    UINT8  *OpRomRevision,           OPTIONAL
  OUT    VOID   **ConfigUtilityCodeHeader OPTIONAL
  )
{
  BOOLEAN                 Match;
  UINT16                  *DeviceIdList;
  EFI_PCI_ROM_HEADER      RomHeader;
  PCI_3_0_DATA_STRUCTURE  *Pcir;
  VOID                    *BackupImage;
  VOID                    *BestImage;


  if (*ImageSize < sizeof (EFI_PCI_ROM_HEADER)) {
    return EFI_NOT_FOUND;
  }

  BestImage     = NULL;
  BackupImage   = NULL;
  RomHeader.Raw = *Rom;
  while (RomHeader.Generic->Signature == PCI_EXPANSION_ROM_HEADER_SIGNATURE) {
    if (RomHeader.Generic->PcirOffset == 0 ||
        (RomHeader.Generic->PcirOffset & 3) !=0 ||
        *ImageSize < RomHeader.Raw - (UINT8 *) *Rom + RomHeader.Generic->PcirOffset + sizeof (PCI_DATA_STRUCTURE)) {
      break;
    }

    Pcir = (PCI_3_0_DATA_STRUCTURE *) (RomHeader.Raw + RomHeader.Generic->PcirOffset);
    //
    // Check signature in the PCI Data Structure.
    //
    if (Pcir->Signature != PCI_DATA_STRUCTURE_SIGNATURE) {
      break;
    }

    if (((UINTN)RomHeader.Raw - (UINTN)*Rom) + Pcir->ImageLength * 512 > *ImageSize) {
      break;
    }

    if (Pcir->CodeType == PCI_CODE_TYPE_PCAT_IMAGE) {
      Match = FALSE;
      if (Pcir->VendorId == VendorId) {
        if (Pcir->DeviceId == DeviceId) {
          Match = TRUE;
        } else if ((Pcir->Revision >= 3) && (Pcir->DeviceListOffset != 0)) {
          DeviceIdList = (UINT16 *)(((UINT8 *) Pcir) + Pcir->DeviceListOffset);
          //
          // Checking the device list
          //
          while (*DeviceIdList != 0) {
            if (*DeviceIdList == DeviceId) {
              Match = TRUE;
              break;
            }
            DeviceIdList ++;
          }
        }
      }

      if (Match) {
        if (Csm16Revision >= 0x0300) {
          //
          // Case 1: CSM16 3.0
          //
          if (Pcir->Revision >= 3) {
            //
            // case 1.1: meets OpRom 3.0
            //           Perfect!!!
            //
            BestImage  = RomHeader.Raw;
            break;
          } else {
            //
            // case 1.2: meets OpRom 2.x
            //           Store it and try to find the OpRom 3.0
            //
            BackupImage = RomHeader.Raw;
          }
        } else {
          //
          // Case 2: CSM16 2.x
          //
          if (Pcir->Revision >= 3) {
            //
            // case 2.1: meets OpRom 3.0
            //           Store it and try to find the OpRom 2.x
            //
            BackupImage = RomHeader.Raw;
          } else {
            //
            // case 2.2: meets OpRom 2.x
            //           Perfect!!!
            //
            BestImage   = RomHeader.Raw;
            break;
          }
        }
      } else {
        DEBUG ((DEBUG_ERROR, "GetPciLegacyRom - OpRom not match (%04x-%04x)\n", (UINTN)VendorId, (UINTN)DeviceId));
      }
    }

    if ((Pcir->Indicator & 0x80) == 0x80) {
      break;
    } else {
      RomHeader.Raw += 512 * Pcir->ImageLength;
    }
  }

  if (BestImage == NULL) {
    if (BackupImage == NULL) {
      return EFI_NOT_FOUND;
    }
    //
    // The versions of CSM16 and OpRom don't match exactly
    //
    BestImage = BackupImage;
  }
  RomHeader.Raw = BestImage;
  Pcir = (PCI_3_0_DATA_STRUCTURE *) (RomHeader.Raw + RomHeader.Generic->PcirOffset);
  *Rom       = BestImage;
  *ImageSize = Pcir->ImageLength * 512;

  if (MaxRuntimeImageLength != NULL) {
    if (Pcir->Revision < 3) {
      *MaxRuntimeImageLength = 0;
    } else {
      *MaxRuntimeImageLength = Pcir->MaxRuntimeImageLength * 512;
    }
  }

  if (OpRomRevision != NULL) {
    //
    // Optional return PCI Data Structure revision
    //
    if (Pcir->Length >= 0x1C) {
      *OpRomRevision = Pcir->Revision;
    } else {
      *OpRomRevision = 0;
    }
  }

  if (ConfigUtilityCodeHeader != NULL) {
    //
    // Optional return ConfigUtilityCodeHeaderOffset supported by the PC-AT ROM
    //
    if ((Pcir->Revision < 3) || (Pcir->ConfigUtilityCodeHeaderOffset == 0)) {
      *ConfigUtilityCodeHeader = NULL;
    } else {
      *ConfigUtilityCodeHeader = RomHeader.Raw + Pcir->ConfigUtilityCodeHeaderOffset;
    }
  }

  return EFI_SUCCESS;
}


static EFI_STATUS csmwrap_pci_vgaarb(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    EFI_PCI_IO_PROTOCOL *PciIo = priv->vga_pci_io;
    UINT64 Attributes = 0;
    UINT64 Supported = 0;
    BOOLEAN unsupported = FALSE;

    if (!PciIo) {
        return -1;
    }

    Status = PciIo->Attributes(PciIo, EfiPciIoAttributeOperationSupported,
                               0, &Supported);

    if (EFI_ERROR(Status)) {
        printf("%s: Failed to get supported attributes: %d\n", __func__, Status);
        return Status;
    }

    Attributes = Supported & (EFI_PCI_IO_ATTRIBUTE_VGA_IO | EFI_PCI_IO_ATTRIBUTE_VGA_IO_16);

    if (Attributes == 0) {
        printf("%s: No VGA IO attributes support\n", __func__);
        unsupported = TRUE;
    } else if (Attributes == (EFI_PCI_IO_ATTRIBUTE_VGA_IO | EFI_PCI_IO_ATTRIBUTE_VGA_IO_16)) {
        Attributes = EFI_PCI_IO_ATTRIBUTE_VGA_IO; // We want to use regular VGA IO
    }

    if (Supported & EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY) {
        Attributes |= EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY;
    } else {
        printf("%s: No VGA memory attributes support\n", __func__);
        unsupported = TRUE;
    }

    if (unsupported) {
        printf("%s: Unable to select attribute\n", __func__);
        return -1;
    }

    Status = PciIo->Attributes(PciIo, EfiPciIoAttributeOperationEnable,
                               Attributes, NULL);
    if (EFI_ERROR(Status)) {
        printf("%s: Failed to set attributes: %d\n", __func__, Status);
        return Status;
    }

    printf("%s: Success! Attributes: %llx\n", __func__, Attributes);

    return 0;
}

static EFI_STATUS csmwrap_video_oprom_init(struct csmwrap_priv *priv)
{
    EFI_STATUS Status;
    PCI_TYPE00 PciConfigHeader;
    EFI_PCI_IO_PROTOCOL *PciIo = priv->vga_pci_io;
    UINTN  LocalRomSize;
    VOID  *LocalRomImage;

    if (!PciIo || !PciIo->RomImage || !PciIo->RomSize) {
        DEBUG((DEBUG_ERROR, No PCI I/O protocol or RomImage function\n));
        return EFI_UNSUPPORTED;
    }

    LocalRomSize  = (UINTN) PciIo->RomSize;
    LocalRomImage = PciIo->RomImage;

    PciIo->Pci.Read (
            PciIo,
            EfiPciIoWidthUint32,
            0,
            sizeof (PciConfigHeader) / sizeof (UINT32),
            &PciConfigHeader
            );

    Status = GetPciLegacyRom (
             0x0300, // ???
             PciConfigHeader.Hdr.VendorId,
             PciConfigHeader.Hdr.DeviceId,
             &LocalRomImage,
             &LocalRomSize,
             NULL /* RuntimeImageLength */,
             NULL /* OpromRevision */,
             NULL /* &LocalConfigUtilityCodeHeader */
             );

    if (EFI_ERROR(Status)) {
        DEBUG((DEBUG_ERROR, "GetPciLegacyRom failed: %r\n", Status));
        return Status;
    }

    vbios_loc = LocalRomImage;
    vbios_size = LocalRomSize;

    priv->video_type = CSMWRAP_VIDEO_OPROM;

    printf("Video Initialisation Succeed with OpROM\n");

    return 0;
}

static EFI_STATUS csmwrap_video_seavgabios_init(struct csmwrap_priv *priv)
{
    struct cb_framebuffer *cb_fb = &priv->cb_fb;
    unsigned long fb_addr = 0;
    EFI_STATUS status;
    EFI_GRAPHICS_OUTPUT_PROTOCOL *gop = priv->gop;
    EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info = NULL;
    UINTN isiz = sizeof(EFI_GRAPHICS_OUTPUT_MODE_INFORMATION), currentMode;

    if (!gop) {
        return EFI_UNSUPPORTED;
    }

    /* FIXME: What if it's not a VBE mode? */
    currentMode = gop->Mode ? gop->Mode->Mode : 0;

    /* we got the interface, get current mode */
    status = gop->QueryMode(gop, currentMode, &isiz, &info);
    if(EFI_ERROR(status)) {
        printf("unable to get current video mode\n");
        return -1;
    }

    printf("%c %3d. %4d x%4d (pitch %4d fmt %d r:%06x g:%06x b:%06x)\n",
        '*', currentMode,
        info->HorizontalResolution, info->VerticalResolution, info->PixelsPerScanLine, info->PixelFormat,
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor?0xff:(
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff0000:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.RedMask:0)),
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor ||
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff00:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.GreenMask:0),
        info->PixelFormat==PixelRedGreenBlueReserved8BitPerColor?0xff0000:(
        info->PixelFormat==PixelBlueGreenRedReserved8BitPerColor?0xff:(
        info->PixelFormat==PixelBitMask?info->PixelInformation.BlueMask:0)));

    fb_addr = (unsigned long)gop->Mode->FrameBufferBase;

    printf("EFI Framebuffer: %lx\n", fb_addr);

    if (!fb_addr) {
        printf("Framebuffer invalid.\n");
        return EFI_UNSUPPORTED;
    }

    cb_fb->physical_address = fb_addr;
    cb_fb->x_resolution = info->HorizontalResolution;
    cb_fb->y_resolution = info->VerticalResolution;
    /* Always 32 bbp */
    cb_fb->bytes_per_line = info->PixelsPerScanLine * 4;
    cb_fb->bits_per_pixel = 32;

    switch (info->PixelFormat) {
        case PixelRedGreenBlueReserved8BitPerColor:
            cb_fb->red_mask_pos = 0;
            cb_fb->red_mask_size = 8;
            cb_fb->green_mask_pos = 8;
            cb_fb->green_mask_size = 8;
            cb_fb->blue_mask_pos = 16;
            cb_fb->blue_mask_size = 8;
            cb_fb->reserved_mask_pos = 24;
            cb_fb->reserved_mask_size = 8;
            break;
        case PixelBlueGreenRedReserved8BitPerColor:
            cb_fb->blue_mask_pos = 0;
            cb_fb->blue_mask_size = 8;
            cb_fb->green_mask_pos = 8;
            cb_fb->green_mask_size = 8;
            cb_fb->red_mask_pos = 16;
            cb_fb->red_mask_size = 8;
            cb_fb->reserved_mask_pos = 24;
            cb_fb->reserved_mask_size = 8;
            break;
        case PixelBitMask:
            // Calculate position (find first set bit)
            cb_fb->red_mask_pos = __builtin_ffs(info->PixelInformation.RedMask) - 1;
            cb_fb->green_mask_pos = __builtin_ffs(info->PixelInformation.GreenMask) - 1;
            cb_fb->blue_mask_pos = __builtin_ffs(info->PixelInformation.BlueMask) - 1;
            cb_fb->reserved_mask_pos = __builtin_ffs(info->PixelInformation.ReservedMask) - 1;

            // Calculate size (count set bits)
            cb_fb->red_mask_size = __builtin_popcount(info->PixelInformation.RedMask);
            cb_fb->green_mask_size = __builtin_popcount(info->PixelInformation.GreenMask);
            cb_fb->blue_mask_size = __builtin_popcount(info->PixelInformation.BlueMask);
            cb_fb->reserved_mask_size = __builtin_popcount(info->PixelInformation.ReservedMask);
            break;
        default:
            printf("Unsupported pixel format: %d\n", info->PixelFormat);
            return EFI_UNSUPPORTED;
    }

    vbios_loc = vgabios_bin;
    vbios_size = sizeof(vgabios_bin);

    priv->video_type = CSMWRAP_VIDEO_SEAVGABIOS;

    printf("Video Initialisation Succeed with SeaVGABIOS GOP\n");

    return 0;

}

static EFI_STATUS csmwrap_video_fallback(struct csmwrap_priv *priv)
{
    struct cb_framebuffer *cb_fb = &priv->cb_fb;

    cb_fb->physical_address = 0x000A0000;
    cb_fb->x_resolution = 1024;
    cb_fb->y_resolution = 768;
    cb_fb->bytes_per_line = 1024 * 4;
    cb_fb->bits_per_pixel = 32;
    cb_fb->red_mask_pos = 0;
    cb_fb->red_mask_size = 8;
    cb_fb->green_mask_pos = 8;
    cb_fb->green_mask_size = 8;
    cb_fb->blue_mask_pos = 16;
    cb_fb->blue_mask_size = 8;
    cb_fb->reserved_mask_pos = 24;
    cb_fb->reserved_mask_size = 8;

    vbios_loc = vgabios_bin;
    vbios_size = sizeof(vgabios_bin);

    priv->video_type = CSMWRAP_VIDEO_FALLBACK;

    printf("WARNING: Using fallback Video, you wont't be able to get display!\n");

    return 0;
}

EFI_STATUS csmwrap_video_prepare_exitbs(struct csmwrap_priv *priv)
{
    /*
     * Unlink Controller before ExitBS, it mat disable FB so we can't
     * do that for other video types.
     */
    if (priv->video_type == CSMWRAP_VIDEO_OPROM) {
        EFI_STATUS Status;

        if (!priv->gop_handle) {
            DEBUG((DEBUG_ERROR, "No GOP handle found\n"));
            return EFI_UNSUPPORTED;
        }

        if (gBS->Hdr.Revision < EFI_1_10_BOOT_SERVICES_REVISION && !gBS->DisconnectController) {
            DEBUG((DEBUG_ERROR, "DisconnectController not supported\n"));
            return EFI_UNSUPPORTED;
        }

        Status = gBS->DisconnectController(
                        priv->gop_handle,
                        NULL,
                        NULL
                        );

        if (EFI_ERROR(Status)) {
            DEBUG((DEBUG_ERROR, "DisconnectController failed: %d\n", Status));
            return Status;
        }
    }

    return EFI_SUCCESS;
}

EFI_STATUS csmwrap_video_init(struct csmwrap_priv *priv)
{
    EFI_STATUS status;

    status = FindGopPciDevice(priv);

    if (EFI_ERROR(status) && !priv->gop) {
        printf("Unable to get GOP service\n");
        return -1;
    }

    if (priv->vga_pci_io) {
        /* Some boards will fail on this stage, no worries */
        status = csmwrap_pci_vgaarb(priv);
    }

    if (vbios_loc != NULL) {
        return 0;
    }

    status = csmwrap_video_oprom_init(priv);
    if (status == EFI_SUCCESS) {
        return 0;
    }

    status = csmwrap_video_seavgabios_init(priv);
    if (status == EFI_SUCCESS) {
        return 0;
    }

    status = csmwrap_video_fallback(priv);
    if (status == EFI_SUCCESS) {
        return 0;
    }

    return EFI_UNSUPPORTED;
}

